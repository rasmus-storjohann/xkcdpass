This program is a tool for generating potentially strong passphrases that can be
memorized. It is inspired by http://xkcd.com/936/. It pulls random words 
out of a word list to generate a base passphrase. Various methods can then be used 
to strengthen the passphrase, such as inserting digits between or within the words, 
replacing letters with special characters, etc. Because as pointed out here
https://www.schneier.com/blog/archives/2012/09/recent_developm_1.html 
just stringing together dictionary words into a passphrase is no longer good enough. 

Most importantly, you should not memorize most of your passphrases. Use a password manager
to store long arbitrary passphrases (e.g. $3Fzli2Bl")'AjZYm0,,Pz%) for almost all your 
accounts, and memorize onlhy the passphrase protecting your password manager file
(obviously), your email and perhaps one or two other things. Keepass 
http://sourceforge.net/projects/keepassx/ and LastPass https://lastpass.com/
are good alternatives for offline and online storage, respectively. These tools also 
generate random passwords.

The goal of this program is not only to generate strong passphrases through
its default behavior. I'm also interested in a tool that can generate passphrases
through a range of related procedures, and estimate the strength of these passphrases
against various types of attacks. This should help us to argue rationally about what
tricks are more effective than others at making passphrases stronger.

A passphrase is nothing more than a way for a human to remember arbitrary information. 
We want passphrases to be hard to guess, which means that they have to be highly arbitrary. 
However, we also need them to be easy to remember. Different people may be quite different 
in what they find easy to remember, so by giving a lot of options, I am hoping that this 
program will be able to generate phrases that any given user can remember, but that also 
contains a lot of randomness that is hard for an attacker to guess.

Two methods are used to estimate the strength of the passphrase. First, as the passphrase
is generated, the program keeps count of how many random numbers have been used, and the
range for each. So a random number in the range from 0 to 100 contributes log2(100) bits to the
entropy while a random number in the range from 0 to 5 contributes log2(5) bits. I call this
complexity measure the entropy of the passphrase. Secondly, the finished passphrase is analysed 
for "haystack" complexity as outlined here https://www.grc.com/haystack.htm. 

Each of these two complexity measures imply a different attack model. The haystack complexity 
assumes a particular form of brute force attack, where every passphrase of length N is tried 
before any of length N+1. Furthermore, every passphrase containing lower case letters only is tried 
before any with lower+upper case letters, then lower+digits, then lower+symbols, then 
lower+upper+digits, etc. This approach assumes that the attacker knows almost nothing about 
how your passphrases are generated. 

The entropy measure reflects the challenge faced by an attacker who knows everything about your 
passphrase generation method, including this program, the options that were passed to it, and the 
word list that was used. The only information not available to this hypothetical attacker is the 
values of random numbers used to generate the passphrase. A real attacker will fall somewhere 
between these extremes. The entropy of a passphrase will always be less than the haystack complexity.

I believe neither of these attack models are very realistic, and I'd be interested to figure
out how to model likely attacks better in order to improve estimates of passphrase strengths.

There are lots of suggestions out there for how to make stronger passphrases. Each of
these tends to have a particular attack model in mind. The factors that affect the strength of 
passphrases generated by this program are:

* The word list file: The more words in the word list, the higher the complexity of
  the passphrase. Each word in the passphrase contributes log2(N) bits of complexity, where
  N is the number of words in the word list. Ideally you should use a word list that
  matches your vocabulary, since you want it to be as large as possible but not so 
  large that you need to memorize new words when memorizing your passphrase. The
  sample dictionary included here contains just over 1400 words, while /usr/share/dict/words 
  on my linux system contains almost 73,000.

* The length of the passphrase, i.e. the number of words, is the most important factor.
  The contribution for an N-word phrase is N*log2(M) where M is the number of words in the
  word list.

* Separator character is inserted between the words. As this is a deterministic process,
  it does not contribute to the entropy of the passphrase, but it is a nice way
  to introduce special characters in the passphrase, which increases the haystack complexity.

* The case won't affect complexity very much. Most of the case modes are deterministic so 
  they do nothing for the entropy but they do increase the haystack complexity
  insofar as they ensure that the passphrase contains both upper and lower case letters.
  The "random" mode randomly picks one of three possible capitalization modes for each 
  word, giving about 1.5 bit of entropy per word. It would be possible to randomly
  capitalize each letter, but I think that would be too hard to remember so there's no point.

* Inserting numbers in the passphrase has potential to increase the complexity, since any 
  number less than 100 will add log2(100) or about 6.5 bits just for the value, plus any 
  contribution from the random placement of the number. Numbers can be placed between words, 
  at the end of the word (which amounts to pretty much the same thing, obviously) and within 
  words. Placing the number between words contributes log2(N) where N is the number of words, 
  whereas placing the number withing words contributes log2(M) where M is the number of letters, 
  so its quite a bit more.

* If you believe that a likely attack will involve trying shorter passphrase before longer
  ones, then even very simple ways to make your passphrase longer will make it stronger, such
  as padding at the beginning and/or end with a simple repeated character, such as *****. 
  This idea is outlined in more detail here https://www.grc.com/haystack.htm. However, much 
  like the separator character, padding does not contribute to the entropy of the passphrase.

* Ideas not yet (fully) implemented include stutter, where a syllable in a word is repeated.
  Which syllable and how many repeats is picked randomly so that would add entropy.
  Also misprints where a single letter is repeated or omitted.
